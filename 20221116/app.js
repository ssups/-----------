// Go를 설치하는 이유
// Geth를 빌드하는데 필요한 언어
// Geth => go-ethereum의 약자임
// Geth는 Go언어로 만들어진 이더리움 클라이언트 소프트웨이 이다.
// 권한이 필요한 명령어를 사용할때 앞에 sudo를 붙힌다.

// Go 설치
// ===================================================================
// brew install go
// ===================================================================

// Go 업데이트 하기

// Geth 설치
// ===================================================================
// brew install ethereum
// ===================================================================
// 혹은 geth 홈페이지 들어가서 다운로드하고 압출푸고 나온 geth 파일 usr/src/bin 폴더 안에 넣어주기

// Geth 실행
// iterm 켜서 geth 치면 실행됨

// 가나쉬 설치
// ===================================================================
// npm i -g ganache-cli
// ===================================================================
// 실행
// ===================================================================
// npx ganache-cli
// ===================================================================
// 가나쉬 로컬에서 이더리움 블록체인 가상 네트워크를 생성할수있께 해준다.
// 테스트할수있게 해주는거
// 가나쉬로 생성된 네트워크에서는 채굴기능, p2p기능이 없음
// 블록 /체인 /Tx 와 관련된 기능만 있다.
// 1tx에 1개의 블록 생성
// 가나쉬로 트랜젝션을 발생시키면 실시간 확인이 가능해서 테스트에 용이하다.

// 비트코인과 이더리움의 차이점
// 이더리움의 가장 큰 특징은 스마트 컨트렉트를 구현할수 있다는 점이다.
// 비트코인은 트랜젝션을 만들면 계정의 소유자가 다른 계정의 소유자에게 코인을 전송하는 거래를 주로 하는데

// 이더리움은 스마트 컨트렉트를 통해서 전송뿐만아니라 다른 다양한 기능을 구현할수 있다.
// 스마트 컨트렉트는 조건이 달린 계약형태의 거래를 가능하게 해준다.
// 스마트 컨트렉트를 작성할때 솔리디티를 사용한다.

// 스마트 컨트렉트를 구현할때 이더리움 EVM 이라는걸 사용하고
// Account, Transaction의 내용도 좀 다르다.

// EVM
// Ethereum Virtual Machine
// 분산 네트워크 환경에서 모든 노드들이 스마트컨트렉트에 의해 특정한 결과를 얻어야할때
// 솔리디티 언어로 작성한 코드를 EVM을 통해서 실행시키게 한다.

// 1. 솔리디티로 컨트렉트 코드 작성
// 2. 바이트 코드로 컴파일
// 3. EVM에서 컴파일된 바이트 코드 실행

// 이더리움 스마트 컨트렉트라는 프로그램을 실행할수 있는 플랫폼으로 기능할수 있는 핵심은
// EVM이라는 가상 컴퓨터가 있기 때문이다.
// 우리가 만든 규칙에 따라서 스마트 컨트렉트 코드를 실행하고
// 그 결과를 업데이트 해준다.

// EVM은 가상머신이고 정해진 스마트컨트렉트 규칙에 따라서 코드를 실행하고
// 그 결과로 변한 상태를 업데이트 해준다.

// Account
// 이더리움 네트워크에는 EOA, CA라는 두종류의 계정이 존재하고

// EOA는 외부 소유 계정(Externally Owned Account)
// 개인키로 제어되는 계정으로 코드를 저장하지 않는다.
// 스마트 컨트렉트에 대한 접근을 제어한다.
// EOA로 트랜젝션을 시작할수있다.
// EOA는 다른 EOA또는 CA에 메세지를 보낼수 있으며 이 동작은 개인키를 사용해서 트랜젝션을 만들고 서명하며
// 두개의 EOA 사이에서 발생하는 메세지는 단순히 ETH만을 전송한다.
// EOA에서 CA에 보내는 메세지는 CA에 저장된 코드를 활성화 시킨다.
// 명령 EOA가 전송한 트랜젝션 부터 시작된다고 보면 된다.

// CA는 계약에 대한 계정(Contract Account)
// 스마트 컨트렉트의 로직에서 제어를 하고 스마트 컨트렉트를 저장할수 있다.(코드의 해시를 저장)
// 개인키가 없고 스스로 트랜젝션을 시작할수가 없다.
// 외부로부터 온 트랜젝션에 대한 응답(다른 CA 혹은 EOA로 부터 온)을 통해서 트랜젝션을 실행하수 있다.

// Transaction
// 이더리움 네트워크에서 트랜젝션은 EOA에 의해서 서명되고
// 속성들은
// from: 보내는 계정
// to: 받는 계정
// nonce: 보내는계정이 발생시킨 총 트랜젝션 횟수
// value: 보내는 금액(이더리움)
// gasLimit: 트랜젝션이 사용할수있는 가스의 최대치
// gasPrice: 현재 가스비(기위단위)
// data: 트랜젝션에 담을 데이터
// 비트코인 네트워크와 다른점이 이더리움 네트워크는 가스비(gas fee)라는 개념이 있고
// 가스는 이더리움 네트워크에서 트랜젝션을 생성할때 보내는 사람이 부담하는 수수료의 개념

// Web3 라이브러리를 사용하면 노드간의 통신을 할때
// RPC라는 개념이 나오는데
// RPC라는 개념이 나온 이유
// 분산 네트워크를 프로그래밍으로 쉽게 어떻게 해야 할까에 대한 고민

// 일반적으로 통신 패턴은
// 서버를 켜고 클라이언트에서 서버에 데이터나 행동을 요청
// 서버는 그 데이터를 받고 요청받은 응답을 반환해주고
// 클라이언트는 서버로 부터 응답값을 받아서 본인의 요청을 결과로 받을수 있다.
// http socket ...

// RPC는 원격 프로시저 호출 별도의 원격제어를 위한 코딩없이 다른 주소공간에서
// 함수나 프로시저를 실행할수 있게 하는 프로세스간 통신기술
// 원격 프로시저를 호출하면 프로그래머가 로컬위치에 있든 원격위치에 있든
// 실행프로그램의 함수를 동일한 코드를 이용할수 있다.
//

// 함수는 input에 대한 output의 발생을 목적으로 하고
// 프로시저는 결과보다는 명령 단위가 수행하는 절차를 목적으로 한다.

// 가나쉬에서 curl을 사용해서 요청을 보내고 확인하는 법

// curl은 client URL

// 클라이언트에서 소스코드를 손쉽게 웹브라우저처럼 활용할수 있게 해주는 기술
// 서버 통신할수 있는 커맨드 명령어 툴이다. 웹개발에서 많이 사용되는 기술
// 장점으로는 다양한 프로토콜을 지원한다는 점이 있다.

// DICT, FILE, FTP, FTPS, Goher, HTTP, HTTPS, IMAPS, LDAP, LDAPS 등등...

// url을가지고 할수있는건 왠만하면 다 할수있다 라고 보면 된다.
// HTTP프로토콜을 사용해서 페이지의 데이터를 가져온다거나 파일을 다운받을수도 있다.
// curl [-option] 페이지 주소 쓰면 페이지의 소스가 화면에 출력된다.

// npx ganache-cli로 가나쉬 실행시켜놓고
// curl -X POST -H "content-type:application/json" --data "{id: soon}" http://localhost:3000

// -X 요청 메소드
// -H 요청 헤더 내용
// -data(-d로 써도 가능) 요청 바디 내용 작성

// 가나쉬로 생성한 이더리움 클라이언트에
// curl을 사용해서 RPC 요청을 보내보자
// {
//  "id" : 1215 -> 체인의 아이디, 있어도되고 없어도 된다.
//  "jsonrpc" : "2.0" -> json으로 인코딩한 프로시저 호출 (필수)
//  "method" : "eth_accounts" -> 이더리움 클라이언트에 구성되어있는 메소드 명 (필수)
//  "params" : [] -> 메소드의 인자값
// }

// 계정을 가져오기
// curl -X POST -H "Content-type : application/json" --data '{"jsonrpc" : "2.0","method" : "eth_accounts", "params" :[]}' http://localhost:8545

// 잔액 조회하는 함수이름 "eth_getBalance"
// 이 함수는 params로 인수 2개를 전달하고
// 첫번째에는 계정의 주소
// 두번째에는 몇번째 블록을 조회할것인지 넣는다.

// curl -X POST -H "Content-type:application/json" --data '{"jsonrpc" : "2.0", "method" : "eth_getBalance", "params" : ["지갑주소","latest"]}' http://localhost:8545
// cf) curl -X POST -H "Content-type:application/json" --data '{"jsonrpc" : "2.0", "method" : "eth_getBalance", "params" : ["0xD83dEeF9C78DEBC9297D14d8DE62684d9C91561D","latest"]}' http://localhost:8545

// 이더리움 클라이언트에게 RPC를 요청보내는 방법이다.

// Web3 라이브러리
// Web3.js라는 라이브러리를 제공받아서 이더리움 네트워크와 상호작용을 할수있는 다양한 함수를
// 제공받아 사용할수있다.
// 위에서 해본 RPC 요청을 쉽게 보낼수있게 해주는 라이브러리

// npm init -y
// npm i  -D jest
// npm i web3

// packkage.json 파일에서 test 부분  "test" : "jest" 로 바꿔주고
// jest.config.js 파일 만들어주기

// ethereumjs-tx 라이브러리 설치
// npm i ethereumjs-tx

// 네트워크 추가 누르고
// 수동으로 추가
// 네트워크 이름 본인이 지정
// 가나쉬 URL 넣어주고 http://127.0.0.1:8545
// 가나쉬는 기본으로 체인 아이디가 1337
// 변경하고 싶으면 npx ganache-cli --chainId "정하고 싶은 체인 아이디"
// 통화기호는 ETH

// 네트워크 이름 : 아무거나
// 새 RPC URL  : http://127.0.0.1:8545
// 체인 ID : 1337
// 통화 기호 : ETH

// 프론트와 메타마스크 연결
// Dapp을 만드는 기초 작업중 하나
// 트랜잭션을 보낼 때 사용자의 개인키를 사용해서 서명을 만드는 과정을 거쳐
// 개인키를 서버에 저장 하는것이 많이 위험 하기 때문에

// 사용자의 개인키는 메타마스크가 주체가 되고 프론트에서 메타마스크에 요청을 주고
// 요청을 메타마스크가 받아서 사용자의 개인키를 이용해 서명을 만들어 트랜잭션을 발생 시킨후
// 블록체인 네트워크로 요청을 보낸다
// 메타마스크는 프론트에서 보낸 요청을 트랜잭션을 발생시켜 블록체인 네트워크로 보낸다는것

// 요청
// 프론트 ->  input -> 메타마스크(지갑) -> 블록체인 네트워크
// 메타 마스크 : 사용자의 개인키를 이용해서 서명 만들고 전달받은 데이터와 서명을 합쳐서
// 블록체인 네트워크로 전달

// 응답
// 블록체인 네트워크 -> 메타마스크(지갑) -> 프론트

// 프론트 서버랑 메타마스크가 서로 요청 응답 받을 수 있게 만들어 주기만 하면됨
// 쇼핑몰을 예를 들어 상품들이 등록되어 있고 사용자가 코인이나 토큰으로 구매를 할 때
// 상품데이터 까지 블록체인 네트워크에 저장하면 너무 비효율적이기 때문에

// 프론트 백엔드 같이 구현해서 상품 데이터는 DB에 저장하고 상품 목록을 불러오고
// 특정 삼품의 정보들을 가져올 땐 백엔드 서버에 요청해서 가져오는 방식

// 프론트에서 메타마스크로 바로 요청을 보내서 트젝 발생시키는 방법과
// 백엔드에서 서명을 제외한 트잭 객체를 만들어서 프론트에 전달하고 프론트에서
// 백엔드에서 받은 트잭 객체를 메타마스크로 전달해 서명과 함께 트잭을 보내는방법
// 백엔드에서 사용자의 개인키를 가지고 서명을 만들어서 서명까지 포함된 트잭을 블록체인 네트워크로 보내는방법

// 중요한건 사용자의 개인키로 서명을 만드는게 우리가 아니고 서명을 만들어주는건 메타마스크가 된다는것