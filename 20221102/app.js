// typeScript로 블록 생성 만들기

// 환경 설정 하고

// ts-node 설치
// ============================================================================
// npm i -D typescript ts-node @types/node
// ============================================================================

// tsconfig.json 만들기
// ============================================================================
// tsc --init
// ============================================================================

// tsconfig.json에서 paths 사용할거라
// ============================================================================
// npm i -D tsconfig-paths
// ============================================================================

// 필요한모듈 설치
// 머큘루트와 해시값 필요 => crypto-js, merkle 설치
// ============================================================================
// npm i crypto-js merkle
// ============================================================================

// typeScript는 외부 모듈을 사용할 경우에 타입 정의파일이 필요하다.
// crypto-js, merkle 모듈 타입을 가져올 수 있는 모듈 설치
// ============================================================================
// npm i --save-dev @types/crypto-js
// npm i --save-dev @types/merkle
// ============================================================================

// 제네시스 블록 만들기

// 테스트하기

// typeScript로 블록체인을 만들어봤는데 객체지향적인 방법으로 코드를 작성했다.
// OOP(객체지향 프로그래밍) => 프로그램의 설계방법 개념의 하나이다.
// OOP는 프로그램을 단순히 실행 및 데이터 처리하는 방법뿐만이 아니라
// 수많은 객체라는 단위를 만들어서 이 객체를 가지고 동작하는 상호작용을 서술한 방식이다.
// OOP에서 객체는 하나의 역할을 수행하는 함수와 변수들의 묶음 데이터로 보면 된다.

// 이런 객체지향 프로그래밍은 프로그램을 만들때 제일 작은 단위부터 만들어가는 방식을 선호한다.
// 그런데 위의 방식으로 한다면 작성된 코드들의 테스트가 어렵다는 단점이 있고
// 이러한 단점 때문에  라이브러리를 사용해서 테스트를 한다.

// 그냥 개발이 아니라 테스트 코드를 작성하면서 개발해나가는게
// TDD(Test Driven Development)

// 테스트를 위해서 Jest라는 라이브러리를 써보자
// ============================================================================
// npm i -D ts-jest @types/jest babel-core
// npm i -D @babel/preset-typescript @babel/preset-env
// ============================================================================
// 설치하고 babel.config.js 랑 jest.config.ts 파일두개 만들어주기

// 체인 만들기
// block 클래스로 만들 블록들을 체인으로 연결시켜줄 chain 클래스를 만들어보자.
// chain 클래스에는 생성한 블록을 배열로 담아서 블록체인을 만들 예정
// 이미 지금 우리가 만든 블록은 블록의 속성으로 체이닝 이미 이뤄지고 있는데
// 이전 블록 해시 값을 속성으로 가지고 있기 때문에 특정 블록기준으로 이전 블록 해시 값이 달라지면
// 현재 블록의 이전 해시값과 불일치가 발생해서 연결 고리가 끈긴다.
// chain클래스를 따로 만들어서 생성된 블록을 하나의 배열안에 담아주는 역할을 할예정
// 이렇게 하는 이유는 이후에 우리가 마이닝 할때 난이도 계산을 하기 위해서

// POW (Proof of Work : 작업증명)

// 작업 증명 역사
// 1993년 모니 나노어이가 작업증명의 기본 개념을 고안했다.
// 1997년 영국의 암호학자인 애덤백의 해시캐시고 이후에 2009년 이 기술은
// 사토시 나카모토라는 사람이 비트코인에 작업증명을 적용시켜 오느날까지 사용된다.

// 해시캐시는 대량으로 스팸메일을 방지하고자 고안된 것.
// 이메일을 보내기 위해서 작업증명 알고리즘을 이용해서 해시값을 찾고
// 그 보상으로 우표같은 것을 발행했다.
// 이 과정이 시간과 비용이 많이들고 대량 발생되는 스펨메일을 막을수있는 방법으로 책택되었다.

// 작업증명 방식은 거래가 발생하면 해당 거래가 유용한지에 대한 합의 검증 방식.
// 논스값을 사용한다.

// 간단한 설명
// 작업증명은 어려운 수학문제를 푸는것과 마찬가지이고
// 작업증명을 하는것을 채굴이라고 부른다.
// 채굴을 한 사람에게(작업증명을 한 사람에게) 보상으로 코인을 발급한다.

// 여기서 특정 조건을 만족하는 논스값을 찾는 것이다.

// 블록체인 상의 모든 참여자가 동일한 순서로 블록을 연결하기 위해선
// 합의 알고리즘이 필요한데
// 대표적인 합의 알고리즘에는 POW, POS, DPOS, POA 등이 있다.

// 만약 난이도가 4라면
// 논스 ???
// 0000 이상인 해시값(목표값)이 나올때까지
// 논스를 0에서 계속 하나씩 더하면서(해싱을 해서) 목표값을 찾는것이다.
// 0000 -> 00000

// "작업 증명 방식(POW)"는 목표값 이하의 해시값을 찾는과정을 무수히 반복해서
// 해당작업에 참여했음을 증명하는 방식의 알고리즘이다.

// 작업 증명 알고리즘의 필요성은 네트워크 상의 모든 노드가 동시에 블록을 만들수 없게 하는것에 있다.
// (작업증명을 통과해야만 새로운 블록을 추가 생성할수있게됨)

// 작업증명 알고리즘은 Difficulty 조절 알고리즘을 이용해서 약 10분당 1개의 블록이 생성되는 것을 보장하게 된다.

// 난이도 조정 블록 범위 => 10
// 블록의 생성 시간 (단위 : 분) => 10
// 생성 시간 (단위 : 초) => 60

// Difficulty 조절 알고리즘은 다음과 같이 설계하자
// 블록 한개가 생성되는 예상 시간을 10분으로 설정하고, 10개의 블록을 한 묶음으로 해서 블록 한묶음이 생성되는
// 예상시간을 6000초라는 값을 할당해주고 이후 10개의 블록이 생성되는데 걸리는 시간이
// timeExpected / 2 보다 작을 경우에는 난이도를 1 증가시키고
// timeExpected * 2 보다 클 경우에는 난이도를 1 감소시킨다.

// P2P네트워크

// block 클래스랑 chain을 가지고
// p2p네트워크 http / ws 환경 구성
// P2P네트워크를 만드는데 http와 ws 웹소켓을 사용해서
// api들을 구성하고 블록을 가져올 express모듈로 서버 동작을 하고 P2P 네트워크를 웹소켓으로 구성
// express와 type-express 설치
// ==========================================================================
// npm i express
// npm i --save-dev @types/express
// ==========================================================================

// ws 웹소켓 설치
// ==========================================================================
// npm i ws
// npm i --save-dev @types/ws
// ==========================================================================

// 머클 트리란 수많은 트랜젝션을 각각 해싱한뒤
// 해싱된 트랜젝션을 다시 두개씩 짝지어 해싱 -> 반복 -> 최종적으로 하나가 남으면 해싱트리 완성
// 1. 첫번째 데이터를 SHA256형태의 해시값으로 변환
// 2. 2개의 노드를 한쌍으로 묶어서 해시값 변환
// 3. 최종적으로 하나만 남을때까지 반복작업
// 4. 결과적으로 블록의 모든 거래를 합친 해시값이 머클루트
// 머클트리는 데이터의 간평성과 확실한 인증이라는 강점을 가진다.

// 블록체인 네트워크 정보를 모두 다운로드하면 용량이 너무 크다.
// 최소한의 정보로만 인증하기 위해서 블록체인을 전부 다운로드하지 않고 머클루트 값만을 받아서 인증을 수행한다.

// SHA256알고리즘을 통해서 256bit로 구성된 64자리 문자열로 암호화해준다.
// 따라서 머클루트 값은 64자이고
// 안전하고 다양한 검증을 빠르게 할수있다.
// 머클트리 자체가 해시로 이루어져있는데
// 그중 하나의 트랜젝션이나 블록의 값이 변조되면 머클루트의 해시값 또한 변조되고
// 결과적으로 잘못된 해시값이 나오게 되면 해당 블록이 잘못된것으로 판단하여
// 해당 블록을 거부하기때문에 안정적인 블록체인 네트워크를 유지할수 있다.

// 블록체인의 동작 방식
// 비트코인 지갑 설치 -> peer연결 -> 블록 다운로드 -> 블록의 검증(해시)

// 비트코인 지갑 생성
// Random 값을 만들고 -> 개인키와 공개키 생성(타원 곡선 알고리즘 사용 ECC) -> 지갑주소 생성(SHA258 & Base58)

// 블록체인의 동작
// 브로드 캐스팅(내가 새로운 트랜젝션을 발생시키면 알려줌)
// 1. 지갑 프로그램에 연결된 peerlist를 확인한다.
// 2. 네트워크 브로드 캐스팅
// 3. 채굴 시작(내가 먼저 다른사람이 만든 트랜젝션을 승인(블록생성) 해주고 수수료를 받음
// 4. 채굴 성공(내가 찾은 nonce를 모두에게 알린다.)
// 5. 채굴에 성공한 블록을 전달
// 6. 네트워크 브로드 캐스팅
// 7. 블록을 검증을 한후 블록체인에 연결한다.
// 7. 롱기스트 블록체인

// P2P기술에서 P는 peer(동등한 사용자)를 의미하는데
// P2P기술에서 사용자 모두가 자체적으로 서버 혹은 클라이언트가 될수있음을 의미한다.
// P2P는 서로 다른 사용자들끼리 자료를 주고받는것을 의미한다.

// 비트코인 화폐를 발행하는 방식을 마이닝이라고 부른다.
// 비트코인 화폐는 10분당 한번씩 일정량 생성되며
// 마이닝에 참여한 사용자중 한명에게 보상이 지급된다.
// 참여자들은 hashcash라는 문제(특정한 조건을 가진 해시값을 찾는것)를 푼다.

// 트랜젝션

// 블록이 생성될때 데이터 부분에 블록 몇번째 이렇게 문자로 담았는데
// 이렇게 한것처름 비트코인 네트워크에서 블록이 생성될때 블록의 data 안에 트랜젝션을 담아준다

// 블록이 생성되면 data에 트랜젝션을 담아주는데
// 첫번째 트랜젝션은 코인베이스 트랜젝션이라 부르고 내용은 마이닝을 했을때 얻는 보상의 내용이 들어간다.
// (채굴한 사람이 얼마나 코인을 보상받았는지)

// 트랜젝션 내용안에 객체가 표현되어있고
// UnspentTransactionOutput(HTXO)이 공간에 잔액을 객체로 저장
// 암호화폐에서 아직 사용되지 않은 거래 출력
// 사용할수있게 승인된 일정량의 디지털 화폐
// 사용되지 않은 미사용 객체

// Tx 0000 = {
// input: {},
// output:{주소: 누구, 얻은코인 : 50}
// }

// UTXO = [{주소: 누구, 얻은코인: 50, 참조트랜젝션: Tx 0000}]
// UTXO 안에있는 객체를 수정하는것이 아니라 삭제하고 새로운 객체를 넣어주는것

// Tx 0001 = {
// input: {주소: 누구, 코인: 50, 참조트젝: Tx 0000},
// output:{주소: 너, 코인: 1},{주소 :누구, 쿠인: 49}
// }

// UTXO에서 {주소: 누구, 얻은코인: 50, 참조트젝: Tx 0000}를 제거하고
// UTOX = [{주소 : 너, 코인: 1, 참조트젝: Tx 0001},
//         {주소: 누구, 코인:49, 참조트젝: Tx 0001}]

// "누구"라는 사용자가 "너"에게 50코인에서 1코인을 보낸다고 가정해서
// input에 Tx 0000 트젝을 속성값으로 전달하고 output에는 두 객체
// {주소: 너, 코인: 1, 참조트젝: Tx 0001},
// {주소: 누구, 코인: 49, 참조트젝: Tx 0001} 객체가 만들어지고
// 이 두객체를 통해서 만들어진 내용이 UTXO에 객체로 담기게 된다(미사용 객체)
//{주소: 누구, 얻은 코인 : 58, 참조 트랜잭션 : Tx 0000} 사용된 객체는 제거

// TX 0002 = {
// input :{ 주소 : 누구, 코인 49, 참조 트랜잭션 : Tx 0001}
// output : [{주소 : 너, 코인 : 20 3}, {주소 : 누구, 코인 : 29 )]
// }

// UTXO = [{주소 : 너, 코인 : 1),} { 주소 : 너, 코인 : 20}, {주소: 누구, 코인:29}]
// UTXO라는 공간은 트랜젝션의 내용을 구성해서 거래 내용을 기록해놓기 위해

// TX 0003 = {
// input : [{ 주소 : 너, 코인 : 1, 참조 트랜잭션 : Tx 0001 ), 1 주소 : 너, 코인 : 20, 참조 트랜잭션 : Tx 0002}]
// output : [{} 주소 : 누구, 코인 : 21 }]
// }
//UTX0 = [{} 주소 : 누구, 코인 : 29, 참조 트랜잭션 : Tx 0002 , 1 주소 : 누구, 코인 : 21, 참조 트랜잭션 : Tx 0003 }]

// 지갑 프로그램에서 사용자 계정 A, B가 있고
// A가 B한테 10 BTC의 전송을 보내면 지갑서버에서 요청을 받아서
// 서명과 트랜젝션 데이터를 만들고 블록체인 서버쪽에서 해당 데이터를 전송
// 블록체인 서버에서 트랜젝션 객체를 만들어준다.

// 트랜젝션 객체가 생겼을때 UTXO 배열안에서 unspentTxOut 객체들이 있는 배열안에서 unspentTxOut 객체를 제거하고 트랜젝션을 통해
// 새로생긴 unspentTxOut 객체들을 UTXO에 추가시켜주는 작업을 하고
// UTXO 내용을 업데이트 해준다.

// 트랜젝션 풀이라는 공간을 만들고 트랜젝션 객체가 생성됐을때 만들어진 트랜젝션을
// 트랜젝션 풀에 담아준다.
// 그리고 블록체인 네트워크 상에 연결된 노드들은 트랜젝션 풀의 내용을 공유한다.
// 블록 마이닝 할때 트랜젝션 풀 안에있는 트랜젝션 객체를 사용해 새로 생성되는 블록의
// data 속성 값으로 넣어준다.
// 그래서 블록이 마이닝 될때 트랜젝션 풀을 업데이트 해주는 부분이 필요하다.

// 노드들이 트랜젝션 풀의 내용을 공유하는 부분은 트랜젝션 객체가 생겼을때 트랜젝션 객체를
// 브로드캐스트 하는 방식

// 윈도우에 geth를 설치해서 쓰면 더 쉬운데 맥 사용자들이 있어서
// 예전엔 윈도우에서 Linux를 쓸려면 가상머신을 사용했어야했는데
// 가상머신을 쓸려면 컴퓨터 메모리를 쪼개서 OS를 따로 설치해서 써야함
// WSL은 이 단점을 보완하고 개발환경을 쉽게 구축 가능

// WSL를 설치해서 사용할거다
// WSL => 윈도우에서 Linux 명령어를 사용할수 있게 도와주는 툴
